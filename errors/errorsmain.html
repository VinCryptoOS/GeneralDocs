<!DOCTYPE html>
<!-- consp11.github.io fdsc  https://consp11.github.io/  -->
<html>
<head>
<title>Ошибки при проектировании криптографии</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>

<link rel="canonical" href="https://vincryptoos.github.io"/>
<meta name="Description" content="Описывает общие ошибки, допускаемые при проектировании криптографии"/>
<meta name="keywords" content="разработка криптографических продуктов">

</head>
<body style="white-space: pre-wrap; font-size: 26px; background-color: #DDDDDD">

1. Использование устаревших и небезопасных примитивов. Невозможность смены в новых версиях ПО, без потери прямой совместимости, устаревшего примитива на другой или смены формата файла.

1.1. Использование средств для обеспечения совместимости между версиями, которые позволяют понижать версию протокола с безопасной на небезопасную. То есть отсутствие принудительного использования более новой версии или возможность отключить такое принудительное использование.
1.2. Отсутствие обязательного применения криптографии или возможность снизить её защищённость или отказаться от неё, в том числе, в результате ошибок, ручных или автоматических переключений на нешифрованный канал при невозможности создать шифрованный и т.п.
В том числе, возможность подключения по http, если недоступен https (неиспользование HSTS).

2. Использование только одного примитива, использование одного хеша на один примитив вместо двух (если длина имеет значение). То есть доверие только одному криптографическому примитиву.

3. Отсутствие закрытия двумя схемами шифрования (CBC и гаммированием, например)

4. Отсутствие учёта интерактивности в криптографии и возможности повторной отсылки изменённых сообщений или возможности проведения атаки с заданным открытым или шифротекстом.

5. Нарушение правил проектирования:
	5.1. В каждом массиве данных, при обработке этого массива мы должны знать:
		1) Достигли ли мы конца массива, логического блока на этом байте
		2) Как интерпретировать следующий байт: он должен быть интерпретирован однозначно (то есть не быть, например, либо дополнением, либо значением, в зависимости от его собственного значения).
		3) Если злоумышленник изменил массив хотя бы в одном бите, мы должны это заметить без выхода за пределы массива и, желательно, не показывая, что мы заметили это слишком рано.
		4) Интерпретация одного и того же массива разными прикладными алгоритмами должна быть одна и та же. Мягкое отношение к ошибкам (их игнорирование) не допускается.

	В качестве последствий нарушения правила 5.1, см. <a href=https://en.wikipedia.org/wiki/Padding_oracle_attack>Padding Oracle</a>

	5.2. Перед шифрованием, в каждом массиве данных должна быть:
		1) по возможности, нарушена структура (злоумышленнику должно быть неизвестно, где находится шифрованный байт ни относительно начала массива, ни относительно других байтов, даже если он знает, что именно было зашифрованно; если злоумышленник изменяет открытый текст, то ему не должны быть известны различия в перемешанном тексте).
		2) вставлен шум
		3) Массив открытого текста должен быть выровнен по длине
		4) Не должно быть некриптостойких зависимостей между данными внутри одного массива (скажем, crc32) или они должны быть криптостойко закрыты

	5.3. Для того, чтобы злоумышленник мог проверить, верно ли он подобрал пароль/ключ, ему нужно выполнить как можно больше операций. Например, он должен расшифровать весь текст перед тем, как проверить хеш текста. Не должно быть зашифрованных контрольных сумм паролей и прочее для упрощения такой проверки.
	
	5.4. Нужно предполагать как можно большие возможности злоумышленника, если это упрощает анализ и не приводит к серьёзным дополнительным издержкам.
	В частности, можно предполагать, что злоумышленник может выполнить какие-то частные атаки на алгоритмы шифрования. Например, по двум хешам с одним ключом понять, что эти хеши на одном ключе и таким образом установить, что два файла зашифрованны одним и тем же человеком.
		Почти всегда злоумышленник может:
		1) Осуществить налёт на объект и временно завладеть устройством или похитить его
		2) Применить терморектальный криптоанализ
		3) Скрытно проникнуть в слабозащищённые объекты, скрытно украсть, а затем вернуть устройство и т.п.
		4) Осуществить атаки по ПЭМИН и другие не программные атаки, даже если они кажутся сложными или дорогими (что не всегда так)
		5) Воздействовать на канал связи: удалять сообщения, изменять их, посылать повторно те же или изменённые и даже вынудить обманом послать сообщение оператора системы. Поэтому, атака с заданным открытым текстом вполне возможна хоть в каком-либо варианте.
		6) Если он имеет из другого источника эталонные файлы, он может сравнить длину шифротекста с длиной шифротекста эталонного файла даже не зная правильного ключа
		7) Злоумышленник может быть похожим на действия иностранных разведок, ОПГ, террористов либо наоборот, действия гос. органов. Если можно себе представить и реализовать защиту в соотв. ситуациях, то её стоит делать. Т.к. в промышленном шпионаже и обычной жизни ситуации более разносторонние и атаки могут происходить по совершенно неожиданным сценариям и векторам. Поэтому учёт нетипичных сценариев может помочь закрыть и эти неожиданные каналы.

		Также может быть:
		1) Случайный отказ оборудования
		2) Небрежность со стороны оператора криптграфической системы (от усталости, спешки и т.п.)
		3) Забытые оператором пароли и пин-коды
		
	5.5. По возможности, необходимо пытаться обеспечить защиту от компрометации одних шифротекстов, если скомпрометированны другие шифротексты или ключи.


6. Невыровненность по времени


7. Отсутствие комментариев к проектным решениям и решениям в коде: почему сделано именно так.
Отсутствие указаний на небезопасность вызываемых функций.
Смешивание в одном API функций, идущих на разных уровнях абстракции, что может запутать программиста.
Смешивание в одном API безопасных и небезопасных функции без указания, что и как использовать, и без указания в наименованиях на небезопасность.


8. Отсутствие должной энтропии для инициализации алгоритмов, в том числе, на момент включения устройства.

9. Использование криптографически сгенерированных идентификаторов (тоукенов) или иных объектов без запаса по длине. Запас по длине должен быть всегда, когда это возможно.
В том числе, в случае, если алгоритм генерации будет взломан, дополнительная длина объектов может затруднить их взлом. Аналогично, при плохо энтропии, приходящейся на один байт: большее количество байтов даст большую энтропию.

10. Разработчик часто вообще не защищает то, что можно защитить, потому что система имеет низкую ценность.
Реально, всегда необходимо иметь защиту на случай ошибки приоритизации или ошибки оценки рисков.

Также, желательно, не только использовать основные меры защиты, помогающие предотвратить утечку, но и дополнительные, которые затрудняют действия атакующих. Если эти приёмы защиты не слишком сложны и не привнесут в программу дополнительных потенциальных дефектов и т.п.

11. Переоценка возможностей пользователя и плохо обоснованные ограничения.
Например, ограничение на длину пароля в 32 или 64 символа не позволяет человеку запомнить длинный пароль с низкой энтропией на каждый байт.

12. Неиспользование возможностей рандомизации.
Желательно использовать содержимое открытого текста для дополнительной рандомизации.
Например, шифрование блока хешем открытого текста перед открытым текстом в режиме CBC даст дополнительную рандомизацию для этого режима.
Для режима CBC часто могут не использовать синхропосылку, хотя она там есть, что позволяет сравнить два шифротекста на равенство их начал; поэтому, синхропосылка должна использоваться в обязательном порядке.

13. Неучёт косвенных или перспективных данных по нестойкости, сговору и т.п.
В том числе, некоторые действия субъектов могут быть интерпретированы как сотрудничество или прикрытие закладок. Но могут быть объяснены и какими-то другими обстоятельствами и логикой.
Однако, возможность объяснения данных, указывающих на сговор с одной стороны, другим способом никак не отрицает то, что сговор действительно может быть.

Вообще, до некоторой степени, если не доказано иное, то опасность существует.

14. Допущение оптимизаций с нарушением логики. Например, Intel Meltdown.
Сначала мы должны проверить права на доступ, и только затем начинать этот доступ. Если прав нет, состояние системы никак не должно измениться.


15. Оказание давления на программистов, не связанного с безопасностью: сроки, быстрота исполнения программы и т.п.
Программисты должны стремиться к безопасной, совершенной с технической и логической точки зрения системе.
Она должна быть простой, понятной и интуитивно нравится программистам.


16. Отсылка зашифрованных данных туда, куда их не нужно отсылать с целью повышения производительности, масштабируемости и т.п.
Если человеку не нужно знать данных и работать с ними, то он не должен иметь к ним доступ даже в зашифрованном виде, т.к. иначе мы даём ему возможность атаковать криптографию.


</body>
</html>
