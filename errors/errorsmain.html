<!DOCTYPE html>
<!-- consp11.github.io fdsc  https://consp11.github.io/  -->
<html>
<head>
<title>Ошибки при проектировании криптографии</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>

<link rel="canonical" href="https://vincryptoos.github.io"/>
<meta name="Description" content="Описывает общие ошибки, допускаемые при проектировании криптографии"/>
<meta name="keywords" content="разработка криптографических продуктов">

</head>
<body style="white-space: pre-wrap; font-size: 26px; background-color: #DDDDDD">

1. Использование устаревших и небезопасных примитивов. Невозможность смены, без потери прямой совместимости, устаревшего примитива на другой или смены формата файла.

2. Использование только одного примитива, использование одного хеша на один примитив вместо двух (если длина имеет значение)

3. Отсутствие закрытия двумя схемами шифрования (CBC и гаммированием, например)

4. Отсутствие учёта интерактивности в криптографии и возможности повторной отсылки изменённых сообщений

5. Нарушение правил проектирования:
	5.1. В каждом массиве данных, при обработке этого массива мы должны знать:
		1) Достигли ли мы конца массива, логического блока на этом байте
		2) Как интерпретировать следующий байт: он должен быть интерпретирован однозначно (то есть не быть, например, либо дополнением, либо значением, в зависимости от его собственного значения).
		3) Если злоумышленник изменил массив хотя бы в одном бите, мы должны это заметить без выхода за пределы массива и, желательно, не показывая, что мы заметили это слишком рано.
		4) Интерпретация одного и того же массива разными прикладными алгоритмами должна быть одна и та же. Мягкое отношение к ошибкам (их игнорирование) не допускается.

	В качестве последствий нарушения правила 5.1, см. <a href=https://en.wikipedia.org/wiki/Padding_oracle_attack>Padding Oracle</a>

	5.2. Перед шифрованием, в каждом массиве данных должна быть:
		1) по возможности, нарушена структура (злоумышленнику должно быть неизвестно, где находится шифрованный байт ни относительно начала массива, ни относительно других байтов, даже если он знает, что именно было зашифрованно).
		2) вставлен шум
		3) Массив открытого текста должен быть выровнен по длине
		4) Не должно быть некриптостойких зависимостей между данными внутри одного массива (скажем, crc32) или они должны быть криптостойко закрыты

	5.3. Для того, чтобы злоумышленник мог проверить, верно ли он подобрал пароль/ключ, ему нужно выполнить как можно больше операций. Например, он должен расшифровать весь текст перед тем, как проверить хеш текста. Не должно быть зашифрованных контрольных сумм паролей и прочее для упрощения такой проверки.
	
	5.4. Нужно предполагать как можно большие возможности злоумышленника, если это упрощает анализ и не приводит к серьёзным дополнительным издержкам.
	В частности, можно предполагать, что злоумышленник может выполнить какие-то частные атаки на алгоритмы шифрования. Например, по двум хешам с одним ключом понять, что эти хеши на одном ключе и таким образом установить, что два файла зашифрованны одним и тем же человеком.
		Почти всегда злоумышленник может:
		1) Осуществить налёт на объект и временно завладеть устройством или похитить его
		2) Применить терморектальный криптоанализ
		3) Скрытно проникнуть в слабозащищённые объекты, скрытно украсть, а затем вернуть устройство и т.п.
		4) Осуществить атаки по ПЭМИН и другие не программные атаки, даже если они кажутся сложными или дорогими (что не всегда так)
		5) Воздействовать на канал связи: удалять сообщения, изменять их, посылать повторно те же или изменённые и даже вынудить обманом послать сообщение оператора системы. Поэтому, атака с заданным открытым текстом вполне возможна хоть в каком-либо варианте.
		6) Если он имеет из другого источника эталонные файлы, он может сравнить длину шифротекста с длиной шифротекста эталонного файла даже не зная правильного ключа
		7) Злоумышленник может быть похожим на действия иностранных разведок, ОПГ, террористов либо наоборот, действия гос. органов. Если можно себе представить и реализовать защиту в соотв. ситуациях, то её стоит делать. Т.к. в промышленном шпионаже и обычной жизни ситуации более разносторонние и атаки могут происходить по совершенно неожиданным сценариям и векторам. Поэтому учёт нетипичных сценариев может помочь закрыть и эти неожиданные каналы.

		Также может быть:
		1) Случайный отказ оборудования
		2) Небрежность со стороны оператора криптграфической системы (от усталости, спешки и т.п.)
		3) Забытые оператором пароли и пин-коды


6. Невыровненность по времени

7. Отсутствие комментариев к проектным решениям и решениям в коде: почему сделано именно так

8. Отсутствие должной энтропии для инициализации алгоритмов, в том числе, на момент включения устройства.

9. Использование криптографически сгенерированных идентификаторов (тоукенов) или иных объектов без запаса по длине. Запас по длине должен быть всегда, когда это возможно.
В том числе, в случае, если алгоритм генерации будет взломан, дополнительная длина объектов может затруднить их взлом. Аналогично, при плохо энтропии, приходящейся на один байт: большее количество байтов даст большую энтропию.

10. Разработчик часто вообще не защищает то, что можно защитить, потому что система имеет низкую ценность.
Реально, всегда необходимо иметь защиту на случай ошибки приоритизации или ошибки оценки рисков.

Также, желательно, не только использовать основные меры защиты, помогающие предотвратить утечку, но и дополнительные, которые затрудняют действия атакующих. Если эти приёмы защиты не слишком сложны и не привнесут в программу дополнительных потенциальных дефектов и т.п.

11. Переоценка возможностей пользователя и плохо обоснованные ограничения.
Например, ограничение на длину пароля в 32 или 64 символа не позволяет человеку запомнить длинный пароль с низкой энтропией на каждый байт.

12. Неиспользование возможностей рандомизации.
Желательно использовать содержимое открытого текста для дополнительной рандомизации.
Например, шифрование хеша перед открытым текстом в режиме CBC даст дополнительную рандомизацию для этого режима.
Для режима CBC часто могут не использовать синхропосылку, хотя она там есть, что позволяет сравнить два шифротекста на равенство их начал.

</body>
</html>
